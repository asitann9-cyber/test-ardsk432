"""
üîß Kripto AI Sistemi - Konfig√ºrasyon Dosyasƒ± - G√úNCELLEME
üî• YENƒ∞: Position validation, real-time sync, debug fonksiyonlarƒ± eklendi
üîß D√úZELTME: Test sorunlarƒ± i√ßin kritik fonksiyonlar
"""

import os
import pytz
import logging
import requests
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dotenv import load_dotenv
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# üî• .ENV DOSYASI Y√úKLE
load_dotenv()

# =============================================================================
# üåê TEMEL AYARLAR
# =============================================================================

LOCAL_TZ = pytz.timezone("Europe/Istanbul")
DEFAULT_TIMEFRAME = "15m"
LIMIT = 500 
SYMBOL_LIMIT = None  

# =============================================================================
# üîë LIVE TRADING AYARLARI
# =============================================================================

# Binance API Keys (.env dosyasƒ±ndan)
BINANCE_API_KEY = os.getenv('BINANCE_API_KEY')
BINANCE_SECRET_KEY = os.getenv('BINANCE_SECRET_KEY')
ENVIRONMENT = os.getenv('ENVIRONMENT', 'testnet')  # testnet veya mainnet

# Trading Parametreleri
LIVE_TRADING_ACTIVE = False
INITIAL_CAPITAL = 1000.0  # USDT (sadece referans i√ßin)
MAX_OPEN_POSITIONS = 1
STOP_LOSS_PCT = 0.01  
TAKE_PROFIT_PCT = 0.02 
SCAN_INTERVAL = 5  # saniye

# Risk Y√∂netimi
MAX_POSITION_SIZE_PCT = 33  # Her pozisyon max %33 sermaye
MIN_ORDER_SIZE = 10  # Minimum order b√ºy√ºkl√ºƒü√º (USDT)

# =============================================================================
# üìä TEKNƒ∞K ANALƒ∞Z PARAMETRELERƒ∞
# =============================================================================

VOL_SMA_LEN = 20
DEFAULT_MIN_STREAK = 3
DEFAULT_MIN_PCT = 0.5
DEFAULT_MIN_VOLR = 1.5
DEFAULT_MIN_AI_SCORE = 0.3

# Deviso G√∂sterge Parametreleri
DEVISO_PARAMS = {
    'zigzag_high_period': 10,
    'zigzag_low_period': 10,
    'min_movement_pct': 0.160,
    'ma_period': 20,
    'std_mult': 2.0,
    'ma_length': 10
}

# AI Model Parametreleri
AI_PARAMS = {
    'model_type': 'random_forest',
    'retrain_interval': 50,
    'min_data_for_training': 20,
    'target_profit_threshold': 1.0,
}

# =============================================================================
# üìÅ DOSYA YOLLARI
# =============================================================================

TRADES_CSV = 'ai_crypto_trades.csv'
CAPITAL_CSV = 'ai_crypto_capital.csv'
AI_MODEL_FILE = 'crypto_improved_ai_model.pkl'

# =============================================================================
# üåê API AYARLARI
# =============================================================================

MAX_WORKERS = 8           
REQ_SLEEP = 0.05          
TIMEOUT = 10
AUTO_REFRESH_INTERVAL = 1

# Binance API Endpoints
if ENVIRONMENT == 'testnet':
    BASE = "https://testnet.binancefuture.com"
    WS_BASE = "wss://fstream.binancefuture.com"
else:
    BASE = "https://fapi.binance.com"
    WS_BASE = "wss://fstream.binance.com"

EXCHANGE_INFO = f"{BASE}/fapi/v1/exchangeInfo"
KLINES = f"{BASE}/fapi/v1/klines"

# =============================================================================
# üìù LOGGING AYARLARI
# =============================================================================

def setup_logging():
    """Logging sistemini yapƒ±landƒ±r"""
    logging.basicConfig(
        level=logging.INFO, 
        format='%(asctime)s %(levelname)s %(message)s'
    )
    
    # Dash logger'ƒ± sustur
    dash_logger = logging.getLogger('werkzeug')
    dash_logger.setLevel(logging.WARNING)
    
    return logging.getLogger("crypto-analytics")

# =============================================================================
# üåê HTTP SESSION AYARLARI
# =============================================================================

def create_session():
    """Optimize edilmi≈ü HTTP session olu≈ütur"""
    session = requests.Session()
    session.headers.update({
        "User-Agent": "crypto-analytics/1.0"
    })

    retry = Retry(
        total=3,
        backoff_factor=0.3,  
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET"],
    )
    
    adapter = HTTPAdapter(
        pool_connections=100, 
        pool_maxsize=100, 
        max_retries=retry
    )
    
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    
    return session

# =============================================================================
# üé® UI AYARLARI
# =============================================================================

# Dash uygulama ayarlarƒ±
DASH_CONFIG = {
    'debug': False,
    'host': "127.0.0.1",
    'port': 8050,
    'title': "ü§ñ AI Crypto Analytics + Live Trading Bot"
}

# Tablo g√ºncelleme aralƒ±ƒüƒ± (ms)
TABLE_REFRESH_INTERVAL = 2000

# =============================================================================
# üîß TRADING DEƒûƒ∞≈ûKENLERƒ∞ - SADECE LIVE TRADING
# =============================================================================

# Live Trading Deƒüi≈ükenleri  
live_capital = 0.0
live_positions = {}
live_trading_active = False

# ‚ö†Ô∏è GE√áICI: App.py uyumluluƒüu i√ßin - KULLANILMAYACAK
# Bu attributelar sadece app.py'nin hata vermemesi i√ßin
paper_capital = 0.0  # KULLANILMAZ - sadece compatibility
paper_positions = {}  # KULLANILMAZ - sadece compatibility

# Genel sistem deƒüi≈ükenleri
auto_scan_active = False
current_data = None
current_settings = {
    'timeframe': DEFAULT_TIMEFRAME,
    'min_streak': DEFAULT_MIN_STREAK,
    'min_pct': DEFAULT_MIN_PCT,
    'min_volr': DEFAULT_MIN_VOLR,
    'min_ai': DEFAULT_MIN_AI_SCORE * 100
}
saved_signals = {}

# üîß YENƒ∞: Position tracking deƒüi≈ükenleri
_last_position_sync = None
_position_validation_errors = []

# =============================================================================
# üîß LIVE TRADING KONTROL FONKSƒ∞YONLARI - G√úNCELLENMƒ∞≈û
# =============================================================================

def switch_to_live_mode():
    """Live trading moduna ge√ß"""
    global live_trading_active
    live_trading_active = True
    logging.getLogger("crypto-analytics").info("ü§ñ Live Trading moduna ge√ßildi")

def is_live_mode():
    """Live trading modunda mƒ±? - ARTIK HER ZAMAN TRUE"""
    return True  # Sadece live trading olduƒüu i√ßin her zaman True

def update_live_capital(new_balance: float):
    """üîß G√úNCELLEME: Live trading bakiyesini g√ºncelle - validation eklendi"""
    global live_capital
    
    # Validation
    if not isinstance(new_balance, (int, float)) or new_balance < 0:
        logging.getLogger("crypto-analytics").warning(f"‚ö†Ô∏è Ge√ßersiz capital deƒüeri: {new_balance}")
        return False
    
    old_capital = live_capital
    live_capital = float(new_balance)
    
    # Deƒüi≈üim logu
    if old_capital != live_capital:
        change = live_capital - old_capital
        logging.getLogger("crypto-analytics").info(f"üí∞ Live capital g√ºncellendi: ${old_capital:.2f} ‚Üí ${live_capital:.2f} ({change:+.2f})")
    
    return True

def update_live_positions(new_positions: dict):
    """üîß G√úNCELLEME: Live trading pozisyonlarƒ±nƒ± g√ºncelle - validation eklendi"""
    global live_positions, _last_position_sync
    
    try:
        # Input validation
        if not isinstance(new_positions, dict):
            logging.getLogger("crypto-analytics").error(f"‚ùå Ge√ßersiz positions tipi: {type(new_positions)}")
            return False
        
        # Position validation
        validation_errors = validate_positions_data(new_positions)
        if validation_errors:
            logging.getLogger("crypto-analytics").warning(f"‚ö†Ô∏è Position validation hatalarƒ±: {len(validation_errors)}")
            for error in validation_errors[:3]:  # ƒ∞lk 3 hatayƒ± g√∂ster
                logging.getLogger("crypto-analytics").debug(f"   ‚Ä¢ {error}")
        
        # Deƒüi≈üiklik analizi
        old_symbols = set(live_positions.keys())
        new_symbols = set(new_positions.keys())
        
        added = new_symbols - old_symbols
        removed = old_symbols - new_symbols
        
        # G√ºncelleme
        live_positions = new_positions.copy()
        _last_position_sync = datetime.now(LOCAL_TZ)
        
        # Change log
        if added or removed:
            logging.getLogger("crypto-analytics").info(f"üìä Live positions g√ºncellendi: {len(new_positions)} pozisyon")
            if added:
                logging.getLogger("crypto-analytics").info(f"   ‚ûï Eklenen: {', '.join(added)}")
            if removed:
                logging.getLogger("crypto-analytics").info(f"   ‚ûñ Kaldƒ±rƒ±lan: {', '.join(removed)}")
        else:
            logging.getLogger("crypto-analytics").debug(f"üìä Live positions senkronize: {len(new_positions)} pozisyon")
        
        return True
        
    except Exception as e:
        logging.getLogger("crypto-analytics").error(f"‚ùå Position g√ºncelleme hatasƒ±: {e}")
        return False

def validate_positions_data(positions: dict) -> List[str]:
    """
    üîß YENƒ∞: Position verilerini validate et
    
    Args:
        positions (dict): Position verileri
        
    Returns:
        List[str]: Validation hatalarƒ±
    """
    errors = []
    
    for symbol, position in positions.items():
        try:
            # Temel field kontrol√º
            required_fields = ['symbol', 'side', 'quantity', 'entry_price']
            for field in required_fields:
                if field not in position:
                    errors.append(f"{symbol}: Eksik field '{field}'")
                elif position[field] is None:
                    errors.append(f"{symbol}: Field '{field}' None deƒüeri")
            
            # Veri tipi kontrol√º
            if 'quantity' in position:
                try:
                    qty = float(position['quantity'])
                    if qty <= 0:
                        errors.append(f"{symbol}: Ge√ßersiz quantity {qty}")
                except (ValueError, TypeError):
                    errors.append(f"{symbol}: Quantity parse hatasƒ±")
            
            if 'entry_price' in position:
                try:
                    price = float(position['entry_price'])
                    if price <= 0:
                        errors.append(f"{symbol}: Ge√ßersiz entry_price {price}")
                except (ValueError, TypeError):
                    errors.append(f"{symbol}: Entry_price parse hatasƒ±")
            
            # Side kontrol√º
            if 'side' in position:
                if position['side'] not in ['LONG', 'SHORT']:
                    errors.append(f"{symbol}: Ge√ßersiz side '{position['side']}'")
                    
        except Exception as e:
            errors.append(f"{symbol}: Validation hatasƒ± - {e}")
    
    return errors

def get_live_trading_summary():
    """üîß G√úNCELLEME: Live Trading √∂zetini d√∂nd√ºr - detaylƒ± bilgi eklendi"""
    global _last_position_sync
    
    summary = {
        'capital': live_capital,
        'positions': len(live_positions),
        'active': live_trading_active,
        'symbols': list(live_positions.keys()),
        'last_sync': _last_position_sync.strftime('%Y-%m-%d %H:%M:%S') if _last_position_sync else 'Never',
        'validation_errors': len(_position_validation_errors)
    }
    
    # Position details
    if live_positions:
        total_invested = sum(pos.get('invested_amount', 0) for pos in live_positions.values())
        summary['total_invested'] = total_invested
        
        # Side analizi
        long_count = sum(1 for pos in live_positions.values() if pos.get('side') == 'LONG')
        short_count = len(live_positions) - long_count
        summary['long_positions'] = long_count
        summary['short_positions'] = short_count
    
    return summary

def reset_live_trading():
    """üîß G√úNCELLEME: Live trading verilerini sƒ±fƒ±rla - tam temizlik"""
    global live_trading_active, live_positions, _last_position_sync, _position_validation_errors
    
    live_trading_active = False
    live_positions.clear()
    _last_position_sync = None
    _position_validation_errors.clear()
    
    logging.getLogger("crypto-analytics").info("üîÑ Live trading tamamen sƒ±fƒ±rlandƒ±")

def force_position_sync() -> bool:
    """
    üîß YENƒ∞: Pozisyon senkronizasyonunu zorla - test sorunlarƒ± i√ßin kritik
    
    Returns:
        bool: Senkronizasyon ba≈üarƒ±lƒ± mƒ±
    """
    try:
        global _last_position_sync
        
        logging.getLogger("crypto-analytics").info("üîÑ Pozisyon senkronizasyonu zorlanƒ±yor...")
        
        # Binance'den ger√ßek pozisyonlarƒ± al (eƒüer varsa)
        try:
            # Bu fonksiyon live_trader.py'den √ßaƒürƒ±lacak
            from trading.live_trader import get_current_live_positions
            
            real_positions = get_current_live_positions()
            
            if real_positions != live_positions:
                logging.getLogger("crypto-analytics").info(f"üîÑ Binance pozisyonlarƒ± ile senkronize ediliyor: {len(real_positions)} pozisyon")
                update_live_positions(real_positions)
                return True
            else:
                logging.getLogger("crypto-analytics").debug("‚úÖ Pozisyonlar zaten senkron")
                return True
                
        except ImportError:
            logging.getLogger("crypto-analytics").debug("‚ö†Ô∏è Live trader mod√ºl√º yok - manuel sync")
            _last_position_sync = datetime.now(LOCAL_TZ)
            return True
            
    except Exception as e:
        logging.getLogger("crypto-analytics").error(f"‚ùå Force sync hatasƒ±: {e}")
        return False

def debug_position_state() -> Dict:
    """
    üîß YENƒ∞: Position durumunu debug et - test sorunlarƒ± i√ßin
    
    Returns:
        Dict: Debug bilgileri
    """
    try:
        debug_info = {
            'timestamp': datetime.now(LOCAL_TZ).strftime('%Y-%m-%d %H:%M:%S'),
            'live_capital': live_capital,
            'live_trading_active': live_trading_active,
            'positions_count': len(live_positions),
            'position_symbols': list(live_positions.keys()),
            'last_sync': _last_position_sync.strftime('%Y-%m-%d %H:%M:%S') if _last_position_sync else 'Never',
            'validation_errors_count': len(_position_validation_errors),
            'position_details': {}
        }
        
        # Her pozisyon i√ßin detaylƒ± bilgi
        for symbol, position in live_positions.items():
            debug_info['position_details'][symbol] = {
                'side': position.get('side', 'UNKNOWN'),
                'quantity': position.get('quantity', 0),
                'entry_price': position.get('entry_price', 0),
                'auto_sltp': position.get('auto_sltp', False),
                'has_signal_data': 'signal_data' in position,
                'fields_count': len(position)
            }
        
        # Validation errors
        if _position_validation_errors:
            debug_info['recent_validation_errors'] = _position_validation_errors[-5:]  # Son 5 hata
        
        return debug_info
        
    except Exception as e:
        return {
            'timestamp': datetime.now(LOCAL_TZ).strftime('%Y-%m-%d %H:%M:%S'),
            'error': str(e),
            'live_capital': live_capital,
            'positions_count': len(live_positions) if live_positions else 0
        }

def validate_live_positions() -> Tuple[bool, List[str]]:
    """
    üîß YENƒ∞: Live pozisyonlarƒ± validate et - test sisteminde sorun tespiti i√ßin
    
    Returns:
        Tuple[bool, List[str]]: (ba≈üarƒ±lƒ±_mƒ±, hata_listesi)
    """
    try:
        errors = []
        
        # Temel kontroller
        if not isinstance(live_positions, dict):
            errors.append(f"live_positions tipi hatalƒ±: {type(live_positions)}")
            return False, errors
        
        # Her pozisyon i√ßin detaylƒ± kontrol
        validation_errors = validate_positions_data(live_positions)
        errors.extend(validation_errors)
        
        # Capital kontrol√º
        if not isinstance(live_capital, (int, float)):
            errors.append(f"live_capital tipi hatalƒ±: {type(live_capital)}")
        elif live_capital < 0:
            errors.append(f"live_capital negatif: {live_capital}")
        
        # Position limit kontrol√º
        if len(live_positions) > MAX_OPEN_POSITIONS:
            errors.append(f"Pozisyon limiti a≈üƒ±ldƒ±: {len(live_positions)} > {MAX_OPEN_POSITIONS}")
        
        # Timestamp kontrol√º
        if _last_position_sync:
            age_minutes = (datetime.now(LOCAL_TZ) - _last_position_sync).total_seconds() / 60
            if age_minutes > 10:  # 10 dakikadan eski
                errors.append(f"Position sync ya≈üƒ± fazla: {age_minutes:.1f} dakika")
        
        success = len(errors) == 0
        
        if not success:
            logging.getLogger("crypto-analytics").warning(f"‚ö†Ô∏è Position validation: {len(errors)} hata")
            global _position_validation_errors
            _position_validation_errors.extend(errors)
            # En fazla 20 hata sakla
            _position_validation_errors = _position_validation_errors[-20:]
        
        return success, errors
        
    except Exception as e:
        error_msg = f"Position validation exception: {e}"
        logging.getLogger("crypto-analytics").error(f"‚ùå {error_msg}")
        return False, [error_msg]

# ‚ö†Ô∏è GE√áICI COMPATIBILITY FONKSIYONLARI - App.py i√ßin
def switch_to_paper_mode():
    """Paper mode'a ge√ß - KULLANILMAZ artƒ±k"""
    logging.getLogger("crypto-analytics").warning("‚ö†Ô∏è Paper mode √ßaƒürƒ±sƒ± - artƒ±k sadece Live Trading var!")
    pass

def reset_paper_trading():
    """Paper trading sƒ±fƒ±rla - KULLANILMAZ artƒ±k"""
    logging.getLogger("crypto-analytics").warning("‚ö†Ô∏è Paper reset √ßaƒürƒ±sƒ± - artƒ±k sadece Live Trading var!")
    pass

# =============================================================================
# üì¶ BA≈ûLATMA FONKSƒ∞YONU - G√úNCELLENMƒ∞≈û
# =============================================================================

def initialize():
    """üîß G√úNCELLEME: Sistemin temel bile≈üenlerini ba≈ülat - validation eklendi"""
    logger = setup_logging()
    session = create_session()
    
    logger.info("üöÄ Kripto AI sistemi - SADECE LIVE TRADING")
    logger.info(f"üîë Environment: {ENVIRONMENT}")
    logger.info(f"üìä Maksimum pozisyon: {MAX_OPEN_POSITIONS}")
    logger.info(f"‚è∞ Tarama aralƒ±ƒüƒ±: {SCAN_INTERVAL} saniye")
    logger.info("üéØ Paper Trading KALDIRILDI - Sadece Live Trading")
    
    # API key kontrol√º
    if BINANCE_API_KEY and BINANCE_SECRET_KEY:
        logger.info("‚úÖ Binance API anahtarlarƒ± y√ºklendi")
        logger.debug(f"üîë API Key: {BINANCE_API_KEY[:8]}...")
    else:
        logger.warning("‚ö†Ô∏è Binance API anahtarlarƒ± bulunamadƒ± (.env dosyasƒ±nƒ± kontrol edin)")
    
    # Position validation
    is_valid, validation_errors = validate_live_positions()
    if not is_valid:
        logger.warning(f"‚ö†Ô∏è Ba≈ülangƒ±√ß position validation: {len(validation_errors)} sorun")
    else:
        logger.debug("‚úÖ Position validation ba≈üarƒ±lƒ±")
    
    return logger, session
"""
ü§ñ Live Trading Bot - Ger√ßek Binance API ile Trading
AI sinyallerini ger√ßek paraya √ßeviren bot sistemi (testnet/mainnet uyumlu)
üî• YENƒ∞: Otomatik SL/TP emirleri - Binance sunucu tarafƒ±nda kapatma
üîß D√úZELTME: App.py ile tam uyumlu hale getirildi
"""

import time
import logging
import threading
import pandas as pd
from datetime import datetime
from typing import Dict, Optional, Set
from decimal import Decimal, ROUND_DOWN
import math

try:
    from binance.client import Client
    from binance.enums import *
    BINANCE_AVAILABLE = True
except ImportError:
    BINANCE_AVAILABLE = False
    print("‚ö†Ô∏è python-binance kurulu deƒüil: pip install python-binance")

from config import (
    BINANCE_API_KEY, BINANCE_SECRET_KEY, ENVIRONMENT, LOCAL_TZ,
    INITIAL_CAPITAL, MAX_OPEN_POSITIONS, STOP_LOSS_PCT, TAKE_PROFIT_PCT,
    SCAN_INTERVAL, MIN_ORDER_SIZE, MAX_POSITION_SIZE_PCT,
    current_capital, open_positions, trading_active, current_data, current_settings
)
from data.fetch_data import get_current_price
from data.database import log_trade_to_csv, log_capital_to_csv

logger = logging.getLogger("crypto-analytics")

# Global durum
binance_client: Optional["Client"] = None
live_trading_active: bool = False
live_trading_thread: Optional[threading.Thread] = None


def _sync_server_time(client: "Client", retries: int = 3, sleep_s: float = 0.2) -> None:
    """Binance Futures sunucu saatine g√∂re timestamp offset ayarla."""
    import time as _t
    last_offset = 0
    for i in range(retries):
        try:
            srv = client.futures_time()["serverTime"]
            loc = int(_t.time() * 1000)
            last_offset = int(srv) - loc
            client.timestamp_offset = last_offset
            logger.info(f"‚è±Ô∏è Time sync: offset={last_offset} ms (try {i+1})")
            _t.sleep(sleep_s)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Time sync attempt {i+1} failed: {e}")
            _t.sleep(sleep_s)


class LiveTradingBot:
    """ü§ñ Ger√ßek Binance Trading Bot Sƒ±nƒ±fƒ±"""

    def __init__(self):
        self.client: Optional["Client"] = None
        self.is_connected: bool = False
        self.account_balance: float = 0.0
        self.tradable_cache: Set[str] = set()
        self.symbol_info_cache: Dict[str, Dict] = {}

    def _refresh_tradable_cache(self) -> None:
        """Testnet/Mainnet TRADABLE sembolleri g√ºvenilir bi√ßimde ke≈üfet."""
        try:
            tickers = self.client.futures_symbol_ticker()
            cache = {t["symbol"] for t in tickers if t.get("symbol", "").endswith("USDT")}

            try:
                info = self.client.futures_exchange_info()
                perp_usdt = {
                    s["symbol"] for s in info.get("symbols", [])
                    if s.get("quoteAsset") == "USDT"
                    and s.get("status") == "TRADING"
                    and s.get("contractType") == "PERPETUAL"
                }
                if perp_usdt:
                    cache = cache & perp_usdt
            except Exception as e2:
                logger.debug(f"exchangeInfo kesi≈üimi atlandƒ±: {e2}")

            self.tradable_cache = cache
            logger.info(f"üß≠ TRADABLE (ticker tabanlƒ±) semboller: {len(cache)} adet")
            if cache:
                logger.info("üß≠ √ñrnek: " + ", ".join(list(cache)[:10]))
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Tradable sembol ke≈üfi ba≈üarƒ±sƒ±z: {e}")

    def connect_to_binance(self) -> bool:
        """üîë Binance API'ye baƒülan ve baƒülantƒ±yƒ± doƒürula."""
        global binance_client

        if not BINANCE_AVAILABLE:
            logger.error("‚ùå python-binance k√ºt√ºphanesi y√ºkl√º deƒüil")
            return False

        if not BINANCE_API_KEY or not BINANCE_SECRET_KEY:
            logger.error("‚ùå API anahtarlarƒ± .env dosyasƒ±nda bulunamadƒ±")
            return False

        try:
            if ENVIRONMENT == "testnet":
                self.client = Client(
                    api_key=BINANCE_API_KEY,
                    api_secret=BINANCE_SECRET_KEY,
                    testnet=True,
                )
                self.client.FUTURES_URL = "https://testnet.binancefuture.com/fapi"
                self.client.FUTURES_DATA_URL = "https://testnet.binancefuture.com/futures/data"
                if hasattr(self.client, "futures_api_url"):
                    self.client.futures_api_url = self.client.FUTURES_URL
                if hasattr(self.client, "futures_data_api_url"):
                    self.client.futures_data_api_url = self.client.FUTURES_DATA_URL
                logger.info("üß™ Binance Futures Testnet i√ßin URL'ler override edildi")
            else:
                self.client = Client(
                    api_key=BINANCE_API_KEY,
                    api_secret=BINANCE_SECRET_KEY,
                )
                logger.info("üöÄ Binance Mainnet'e baƒülanƒ±lƒ±yor")

            _sync_server_time(self.client)
            self.client.futures_ping()

            account_info = self.client.futures_account(recvWindow=60000)
            self.account_balance = float(account_info["totalWalletBalance"])
            logger.info(f"‚úÖ API baƒülantƒ±sƒ± ba≈üarƒ±lƒ± - Bakiye: ${self.account_balance:.2f}")

            self._refresh_tradable_cache()

            binance_client = self.client
            self.is_connected = True
            return True

        except Exception as e:
            logger.error(f"‚ùå Binance baƒülantƒ± hatasƒ±: {e}")
            self.is_connected = False
            return False

    def get_account_balance(self) -> float:
        """üí∞ Hesap bakiyesini al."""
        try:
            if not self.client:
                return 0.0
            account_info = self.client.futures_account(recvWindow=60000)
            balance = float(account_info["totalWalletBalance"])
            self.account_balance = balance
            return balance
        except Exception as e:
            logger.error(f"‚ùå Bakiye alma hatasƒ±: {e}")
            return 0.0

    def get_symbol_info(self, symbol: str) -> Dict:
        """üìä Sembol bilgilerini al (cache'li)."""
        if symbol in self.symbol_info_cache:
            return self.symbol_info_cache[symbol]

        try:
            exchange_info = self.client.futures_exchange_info()
            for s in exchange_info["symbols"]:
                if s["symbol"] == symbol:
                    info = {
                        "symbol": symbol,
                        "status": s["status"],
                        "quantity_precision": s["quantityPrecision"],
                        "price_precision": s["pricePrecision"],
                        "lot_size": None,
                        "min_qty": None,
                        "min_notional": None,
                    }
                    
                    for f in s["filters"]:
                        if f["filterType"] == "LOT_SIZE":
                            info["lot_size"] = float(f["stepSize"])
                            info["min_qty"] = float(f["minQty"])
                        elif f["filterType"] == "MIN_NOTIONAL":
                            info["min_notional"] = float(f.get("notional", 0.0))
                    
                    self.symbol_info_cache[symbol] = info
                    return info
            return {}
        except Exception as e:
            logger.error(f"‚ùå Sembol bilgisi alma hatasƒ± {symbol}: {e}")
            return {}

    def _is_tradable_symbol(self, symbol: str) -> bool:
        """üîç Sembol√ºn ger√ßekten trade edilebilir olduƒüunu doƒürula."""
        try:
            if self.tradable_cache and symbol not in self.tradable_cache:
                return False
            _ = self.client.futures_symbol_ticker(symbol=symbol, recvWindow=60000)
            return True
        except Exception as e:
            logger.info(f"‚õî {symbol} tradable deƒüil: {e}")
            return False

    def calculate_position_size(self, symbol: str, price: float) -> float:
        """üìè Pozisyon b√ºy√ºkl√ºƒü√ºn√º hesapla (precision uyumlu)."""
        try:
            max_position_value = self.account_balance * (MAX_POSITION_SIZE_PCT / 100)

            if max_position_value < MIN_ORDER_SIZE:
                logger.warning(f"‚ö†Ô∏è Yetersiz bakiye - Min: ${MIN_ORDER_SIZE}, Mevcut: ${max_position_value:.2f}")
                return 0.0

            raw_qty = max_position_value / price

            info = self.get_symbol_info(symbol)
            lot_size = float(info.get("lot_size") or 0.0)
            min_qty = float(info.get("min_qty") or 0.0)
            min_notional = float(info.get("min_notional") or 0.0)
            quantity_precision = int(info.get("quantity_precision", 8))

            # Quantity precision'a g√∂re yuvarla
            qty = round(raw_qty, quantity_precision)

            # Lot size kontrol√º
            if lot_size > 0:
                qty_steps = qty / lot_size
                qty = math.floor(qty_steps) * lot_size
                qty = round(qty, quantity_precision)

            # Min quantity kontrol√º
            if min_qty > 0 and qty < min_qty:
                logger.warning(f"‚ö†Ô∏è {symbol} minimum quantity altƒ±nda: {qty} < {min_qty}")
                return 0.0

            # Min notional kontrol√º
            if min_notional > 0:
                notional = qty * price
                if notional < min_notional:
                    required_qty = min_notional / price
                    required_qty = round(required_qty, quantity_precision)
                    
                    if lot_size > 0:
                        qty_steps = required_qty / lot_size
                        required_qty = math.ceil(qty_steps) * lot_size
                        required_qty = round(required_qty, quantity_precision)
                    
                    if required_qty * price < min_notional:
                        logger.warning(f"‚ö†Ô∏è {symbol} notional gereksinimi kar≈üƒ±lanamƒ±yor")
                        return 0.0
                        
                    qty = required_qty

            logger.debug(f"üéØ {symbol} Final qty: {qty} (precision: {quantity_precision})")
            return max(qty, 0.0)

        except Exception as e:
            logger.error(f"‚ùå Pozisyon b√ºy√ºkl√ºƒü√º hesaplama hatasƒ±: {e}")
            return 0.0

    def _format_price(self, symbol: str, price: float) -> float:
        """üéØ Fiyatƒ± sembol precision'ƒ±na g√∂re formatla."""
        try:
            info = self.get_symbol_info(symbol)
            price_precision = int(info.get("price_precision", 8))
            return round(price, price_precision)
        except:
            return round(price, 8)

    def open_position(self, signal: Dict) -> bool:
        """üöÄ Pozisyon a√ß + Otomatik SL/TP emirleri."""
        try:
            symbol = signal["symbol"]
            side_txt = signal["run_type"].upper()

            if symbol in open_positions:
                logger.warning(f"‚ö†Ô∏è {symbol} i√ßin zaten a√ßƒ±k pozisyon var")
                return False

            if len(open_positions) >= MAX_OPEN_POSITIONS:
                logger.warning(f"‚ö†Ô∏è Maksimum pozisyon sayƒ±sƒ±na ula≈üƒ±ldƒ±: {MAX_OPEN_POSITIONS}")
                return False

            current_price = get_current_price(symbol)
            if current_price is None:
                logger.error(f"‚ùå {symbol} i√ßin fiyat alƒ±namadƒ±")
                return False

            quantity = self.calculate_position_size(symbol, current_price)
            if quantity <= 0:
                logger.error(f"‚ùå {symbol} i√ßin ge√ßersiz pozisyon b√ºy√ºkl√ºƒü√º")
                return False

            order_side = SIDE_BUY if side_txt == "LONG" else SIDE_SELL

            # Ana market emri
            main_order = self.client.futures_create_order(
                symbol=symbol,
                side=order_side,
                type=ORDER_TYPE_MARKET,
                quantity=quantity,
                recvWindow=60000,
            )

            # Emir durumu kontrol√º
            order_status = main_order.get("status")
            executed_qty = float(main_order.get("executedQty", 0))
            
            logger.info(f"üìã {symbol} Emir Status: {order_status} | Executed: {executed_qty}")
            
            if order_status in ["FILLED", "PARTIALLY_FILLED"] and executed_qty > 0:
                avg_price = float(main_order.get("avgPrice") or current_price)
                
                if executed_qty != quantity:
                    logger.warning(f"‚ö†Ô∏è {symbol} Kƒ±smi dolum: ƒ∞stenen={quantity}, Ger√ßekle≈üen={executed_qty}")
                
                quantity = executed_qty

                # SL/TP fiyatlarƒ± hesapla
                if side_txt == "LONG":
                    stop_loss = self._format_price(symbol, avg_price * (1 - STOP_LOSS_PCT))
                    take_profit = self._format_price(symbol, avg_price * (1 + TAKE_PROFIT_PCT))
                    close_side = SIDE_SELL
                else:
                    stop_loss = self._format_price(symbol, avg_price * (1 + STOP_LOSS_PCT))
                    take_profit = self._format_price(symbol, avg_price * (1 - TAKE_PROFIT_PCT))
                    close_side = SIDE_BUY

                logger.info(f"‚úÖ LIVE POZƒ∞SYON A√áILDI: {symbol} {side_txt} {executed_qty} @ ${avg_price:.6f}")
                logger.info(f"üí∞ Yatƒ±rƒ±lan: ${executed_qty * avg_price:.2f}")
                logger.info(f"üìä SL: ${stop_loss:.6f} | TP: ${take_profit:.6f}")

                # Stop Loss emri (otomatik)
                sl_order_id = None
                try:
                    sl_order = self.client.futures_create_order(
                        symbol=symbol,
                        side=close_side,
                        type="STOP_MARKET",
                        quantity=executed_qty,
                        stopPrice=stop_loss,
                        timeInForce="GTC",
                        recvWindow=60000,
                    )
                    sl_order_id = sl_order["orderId"]
                    logger.info(f"üõë Stop Loss emri verildi: ${stop_loss:.6f} (Order ID: {sl_order_id})")
                except Exception as e:
                    logger.error(f"‚ùå Stop Loss emri hatasƒ± {symbol}: {e}")

                # Take Profit emri (otomatik)
                tp_order_id = None
                try:
                    tp_order = self.client.futures_create_order(
                        symbol=symbol,
                        side=close_side,
                        type="TAKE_PROFIT_MARKET",
                        quantity=executed_qty,
                        stopPrice=take_profit,
                        timeInForce="GTC",
                        recvWindow=60000,
                    )
                    tp_order_id = tp_order["orderId"]
                    logger.info(f"üéØ Take Profit emri verildi: ${take_profit:.6f} (Order ID: {tp_order_id})")
                except Exception as e:
                    logger.error(f"‚ùå Take Profit emri hatasƒ± {symbol}: {e}")

                # Pozisyon verisini kaydet
                position_data = {
                    "symbol": symbol,
                    "side": side_txt,
                    "quantity": executed_qty,
                    "entry_price": avg_price,
                    "invested_amount": executed_qty * avg_price,
                    "stop_loss": stop_loss,
                    "take_profit": take_profit,
                    "entry_time": datetime.now(LOCAL_TZ),
                    "signal_data": signal,
                    "main_order_id": main_order["orderId"],
                    "sl_order_id": sl_order_id,
                    "tp_order_id": tp_order_id,
                    "auto_sltp": True,
                }

                open_positions[symbol] = position_data
                self._log_trade_to_csv(position_data, "OPEN")
                
                if sl_order_id and tp_order_id:
                    logger.info(f"ü§ñ {symbol} otomatik SL/TP emirleri aktif - Binance sunucu tarafƒ±nda kontrol edilecek")
                else:
                    logger.warning(f"‚ö†Ô∏è {symbol} otomatik SL/TP emirleri verilemedi - manuel kontrol yapƒ±lacak")
                
                return True

            logger.error(f"‚ùå Ana emir ba≈üarƒ±sƒ±z: {main_order}")
            return False

        except Exception as e:
            logger.error(f"‚ùå Pozisyon a√ßma hatasƒ± {symbol}: {e}")
            return False

    def close_position(self, symbol: str, close_reason: str) -> bool:
        """üîí Pozisyon kapat + Bekleyen emirleri iptal et."""
        try:
            if symbol not in open_positions:
                logger.warning(f"‚ö†Ô∏è {symbol} i√ßin a√ßƒ±k pozisyon bulunamadƒ±")
                return False

            position = open_positions[symbol]

            # Bekleyen SL/TP emirlerini iptal et
            if position.get("auto_sltp", False):
                sl_order_id = position.get("sl_order_id")
                tp_order_id = position.get("tp_order_id")
                
                for order_id, order_name in [(sl_order_id, "SL"), (tp_order_id, "TP")]:
                    if order_id:
                        try:
                            self.client.futures_cancel_order(symbol=symbol, orderId=order_id, recvWindow=60000)
                            logger.info(f"üö´ {symbol} {order_name} emri iptal edildi (ID: {order_id})")
                        except Exception as e:
                            logger.debug(f"‚ö†Ô∏è {symbol} {order_name} emri iptal edilemedi: {e}")

            # Ana pozisyonu kapat
            close_side = SIDE_SELL if position["side"] == "LONG" else SIDE_BUY

            close_order = self.client.futures_create_order(
                symbol=symbol,
                side=close_side,
                type=ORDER_TYPE_MARKET,
                quantity=position["quantity"],
                recvWindow=60000,
            )

            if close_order.get("status") == "FILLED":
                exit_price = float(close_order.get("avgPrice"))
                if position["side"] == "LONG":
                    pnl = (exit_price - position["entry_price"]) * position["quantity"]
                else:
                    pnl = (position["entry_price"] - exit_price) * position["quantity"]

                logger.info(f"‚úÖ LIVE POZƒ∞SYON KAPANDI: {symbol} {position['side']} | Sebep: {close_reason}")
                logger.info(f"üí≤ Giri≈ü: ${position['entry_price']:.6f} ‚Üí √áƒ±kƒ±≈ü: ${exit_price:.6f} | P&L: ${pnl:.4f}")

                trade_data = position.copy()
                trade_data.update({
                    "exit_price": exit_price,
                    "current_value": position["quantity"] * exit_price,
                    "pnl": pnl,
                    "close_reason": close_reason,
                    "close_time": datetime.now(LOCAL_TZ),
                })

                self._log_trade_to_csv(trade_data, "CLOSED")
                del open_positions[symbol]
                return True

            logger.error(f"‚ùå Pozisyon kapatma ba≈üarƒ±sƒ±z: {close_order}")
            return False

        except Exception as e:
            logger.error(f"‚ùå Pozisyon kapatma hatasƒ± {symbol}: {e}")
            return False

    def monitor_positions(self) -> None:
        """üëÄ A√ßƒ±k pozisyonlarƒ± izle - Otomatik SL/TP olan pozisyonlarƒ± kontrol et."""
        try:
            if not open_positions:
                return

            logger.debug(f"üëÄ {len(open_positions)} a√ßƒ±k pozisyon izleniyor...")
            
            for symbol, position in list(open_positions.items()):
                if position.get("auto_sltp", False):
                    current_price = get_current_price(symbol)
                    if current_price:
                        entry_price = position["entry_price"]
                        if position["side"] == "LONG":
                            pnl_pct = ((current_price - entry_price) / entry_price) * 100
                        else:
                            pnl_pct = ((entry_price - current_price) / entry_price) * 100
                        
                        logger.debug(f"ü§ñ {symbol} (Auto SL/TP): {current_price:.6f} | PnL: {pnl_pct:+.2f}%")

        except Exception as e:
            logger.error(f"‚ùå Pozisyon izleme hatasƒ±: {e}")

    def check_filled_orders(self) -> None:
        """üîç Otomatik SL/TP emirlerinin dolup dolmadƒ±ƒüƒ±nƒ± kontrol et."""
        try:
            symbols_to_remove = []
            
            for symbol, position in list(open_positions.items()):
                if not position.get("auto_sltp", False):
                    continue
                    
                sl_order_id = position.get("sl_order_id")
                tp_order_id = position.get("tp_order_id")
                
                # SL emri kontrol√º
                if sl_order_id:
                    try:
                        sl_order = self.client.futures_get_order(symbol=symbol, orderId=sl_order_id, recvWindow=60000)
                        if sl_order["status"] == "FILLED":
                            logger.info(f"üõë {symbol} Stop Loss otomatik tetiklendi!")
                            self._handle_auto_close(symbol, "Stop Loss - Auto", sl_order)
                            symbols_to_remove.append(symbol)
                            continue
                    except Exception as e:
                        logger.debug(f"SL order check error {symbol}: {e}")
                
                # TP emri kontrol√º
                if tp_order_id:
                    try:
                        tp_order = self.client.futures_get_order(symbol=symbol, orderId=tp_order_id, recvWindow=60000)
                        if tp_order["status"] == "FILLED":
                            logger.info(f"üéØ {symbol} Take Profit otomatik tetiklendi!")
                            self._handle_auto_close(symbol, "Take Profit - Auto", tp_order)
                            symbols_to_remove.append(symbol)
                            continue
                    except Exception as e:
                        logger.debug(f"TP order check error {symbol}: {e}")
            
            # Kapatƒ±lmƒ±≈ü pozisyonlarƒ± kaldƒ±r
            for symbol in symbols_to_remove:
                if symbol in open_positions:
                    del open_positions[symbol]

        except Exception as e:
            logger.error(f"‚ùå Otomatik emir kontrol√º hatasƒ±: {e}")

    def _handle_auto_close(self, symbol: str, close_reason: str, filled_order: Dict) -> None:
        """üîÑ Otomatik kapatƒ±lan pozisyonu i≈üle."""
        try:
            if symbol not in open_positions:
                return
                
            position = open_positions[symbol]
            exit_price = float(filled_order.get("avgPrice", 0))
            
            if position["side"] == "LONG":
                pnl = (exit_price - position["entry_price"]) * position["quantity"]
            else:
                pnl = (position["entry_price"] - exit_price) * position["quantity"]

            logger.info(f"‚úÖ OTOMATIK KAPANI≈û: {symbol} {position['side']} | Sebep: {close_reason}")
            logger.info(f"üí≤ Giri≈ü: ${position['entry_price']:.6f} ‚Üí √áƒ±kƒ±≈ü: ${exit_price:.6f} | P&L: ${pnl:.4f}")

            # Diƒüer bekleyen emri iptal et
            other_order_id = None
            if "Stop Loss" in close_reason:
                other_order_id = position.get("tp_order_id")
            elif "Take Profit" in close_reason:
                other_order_id = position.get("sl_order_id")
                
            if other_order_id:
                try:
                    self.client.futures_cancel_order(symbol=symbol, orderId=other_order_id, recvWindow=60000)
                    logger.info(f"üö´ {symbol} diƒüer bekleyen emir iptal edildi")
                except:
                    pass

            # Trade kaydƒ±
            trade_data = position.copy()
            trade_data.update({
                "exit_price": exit_price,
                "current_value": position["quantity"] * exit_price,
                "pnl": pnl,
                "close_reason": close_reason,
                "close_time": datetime.now(LOCAL_TZ),
            })

            self._log_trade_to_csv(trade_data, "CLOSED")

        except Exception as e:
            logger.error(f"‚ùå Otomatik kapatma i≈üleme hatasƒ± {symbol}: {e}")

    # üîß D√úZELTME: Eksik cancel_pending_orders fonksiyonu eklendi
    def cancel_pending_orders(self) -> None:
        """üö´ Bekleyen emirleri temizle."""
        try:
            # A√ßƒ±k pozisyonu olmayan bekleyen emirleri iptal et
            for symbol, position in list(open_positions.items()):
                if position.get("auto_sltp", False):
                    # Pozisyon varsa emirleri koruyun
                    continue
            
            logger.debug("üßπ Bekleyen emirler kontrol edildi")
            
        except Exception as e:
            logger.error(f"‚ùå Bekleyen emir temizleme hatasƒ±: {e}")

    def fill_empty_positions(self) -> None:
        """üéØ Bo≈ü pozisyon slotlarƒ±nƒ± doldur."""
        try:
            import config
            
            logger.info("üîÑ fill_empty_positions ba≈ülatƒ±ldƒ±")
            
            if not live_trading_active:
                logger.info("‚ùå Live trading aktif deƒüil - √ßƒ±kƒ±lƒ±yor")
                return

            current_positions = len(open_positions)
            logger.info(f"üìä Mevcut pozisyon: {current_positions}/{MAX_OPEN_POSITIONS}")
            
            if current_positions >= MAX_OPEN_POSITIONS:
                logger.info("‚úÖ T√ºm pozisyon slotlarƒ± dolu")
                return

            needed_slots = MAX_OPEN_POSITIONS - current_positions
            logger.info(f"üéØ Gereken slot sayƒ±sƒ±: {needed_slots}")

            current_data_live = config.current_data
            
            if current_data_live is None or current_data_live.empty:
                logger.warning("‚ùå config.current_data bo≈ü - sinyal verisi yok")
                return

            logger.info(f"‚úÖ config.current_data mevcut: {len(current_data_live)} satƒ±r")

            # Filtreleme
            min_ai = float(current_settings.get("min_ai", 30.0))
            min_streak = int(current_settings.get("min_streak", 3))
            min_move = float(current_settings.get("min_pct", 0.5))
            min_volr = float(current_settings.get("min_volr", 1.5))

            df = current_data_live.copy()

            if "ai_score" in df.columns and df["ai_score"].max() <= 1.0:
                df["ai_score"] = (df["ai_score"] * 100.0).clip(0, 100)

            live_min_ai = max(min_ai, 30.0)
            df = df[df["ai_score"] >= live_min_ai]
            df = df[df["run_count"] >= min_streak]
            df = df[df["run_perc"] >= min_move]

            if "vol_ratio" in df.columns:
                df = df[df["vol_ratio"].fillna(0) >= min_volr]

            exclude = set(open_positions.keys())
            df = df[~df["symbol"].isin(exclude)]

            if self.tradable_cache:
                df = df[df["symbol"].isin(self.tradable_cache)]

            if df.empty:
                logger.info(f"üîç Uygun aday yok (AI>={live_min_ai}%)")
                return

            df = df.sort_values(["ai_score", "run_perc", "gauss_run"], ascending=[False, False, False])
            top3 = df.head(3)

            logger.info(f"üéØ En iyi 3 aday (AI>={live_min_ai}%):")
            for _, r in top3.iterrows():
                logger.info(f"   ‚Ä¢ {r['symbol']} | AI={r['ai_score']:.0f}% | run={r['run_count']} | move={r['run_perc']:.2f}%")

            opened = 0
            for _, row in top3.iterrows():
                if opened >= needed_slots:
                    break
                sym = row["symbol"]
                ok = self._is_tradable_symbol(sym)
                logger.info(f"üîç {sym} tradable kontrol√º: {ok}")
                if not ok:
                    continue
                if self.open_position(row.to_dict()):
                    opened += 1
                    time.sleep(1)

            if opened > 0:
                logger.info(f"üöÄ {opened} yeni live pozisyon a√ßƒ±ldƒ± (otomatik SL/TP ile)")
            else:
                logger.info(f"üîç Uygun aday bulunamadƒ±")

        except Exception as e:
            logger.error(f"‚ùå Pozisyon doldurma hatasƒ±: {e}")

    def _log_trade_to_csv(self, trade_data: Dict, status: str) -> None:
        """üìù Trade'i CSV'ye kaydet."""
        try:
            csv_data = {
                "timestamp": datetime.now(LOCAL_TZ).strftime("%Y-%m-%d %H:%M:%S"),
                "symbol": trade_data["symbol"],
                "side": trade_data["side"],
                "quantity": trade_data["quantity"],
                "entry_price": trade_data["entry_price"],
                "exit_price": trade_data.get("exit_price", 0),
                "invested_amount": trade_data["invested_amount"],
                "current_value": trade_data.get("current_value", 0),
                "pnl": trade_data.get("pnl", 0),
                "commission": 0.0,
                "ai_score": trade_data["signal_data"]["ai_score"],
                "run_type": trade_data["signal_data"]["run_type"],
                "run_count": trade_data["signal_data"]["run_count"],
                "run_perc": trade_data["signal_data"]["run_perc"],
                "gauss_run": trade_data["signal_data"]["gauss_run"],
                "vol_ratio": trade_data["signal_data"].get("vol_ratio", 0),
                "deviso_ratio": trade_data["signal_data"].get("deviso_ratio", 0),
                "stop_loss": trade_data["stop_loss"],
                "take_profit": trade_data["take_profit"],
                "close_reason": trade_data.get("close_reason", ""),
                "status": status,
            }
            log_trade_to_csv(csv_data)
        except Exception as e:
            logger.error(f"‚ùå CSV log hatasƒ±: {e}")


# ---------- D√∂ng√º & Kontrol ----------

live_bot = LiveTradingBot()


def live_trading_loop() -> None:
    """üîÑ Ana live trading d√∂ng√ºs√º."""
    global live_trading_active

    logger.info("ü§ñ Live Trading d√∂ng√ºs√º ba≈ülatƒ±ldƒ±")
    loop_count = 0

    while live_trading_active:
        try:
            loop_count += 1
            loop_start = time.time()

            logger.info(f"üîÑ Live d√∂ng√º #{loop_count} - Pozisyon: {len(open_positions)}/{MAX_OPEN_POSITIONS}")

            balance = live_bot.get_account_balance()
            logger.info(f"üí∞ Mevcut bakiye: ${balance:.2f}")

            # Bekleyen emirleri temizle (her d√∂ng√ºde)
            live_bot.cancel_pending_orders()

            # Otomatik SL/TP emirlerini kontrol et
            live_bot.check_filled_orders()

            # Bo≈ü slotlarƒ± doldur
            live_bot.fill_empty_positions()

            # Pozisyonlarƒ± izle (otomatik SL/TP i√ßin minimal)
            live_bot.monitor_positions()

            log_capital_to_csv()

            loop_time = time.time() - loop_start
            logger.info(f"‚è±Ô∏è D√∂ng√º #{loop_count}: {loop_time:.2f}s tamamlandƒ±")

            if open_positions:
                positions_summary = ", ".join(open_positions.keys())
                auto_count = sum(1 for p in open_positions.values() if p.get("auto_sltp", False))
                logger.info(f"üî• A√ßƒ±k pozisyonlar: {positions_summary} (Otomatik SL/TP: {auto_count}/{len(open_positions)})")

            time.sleep(SCAN_INTERVAL)

        except Exception as e:
            logger.error(f"‚ùå Live trading d√∂ng√ºs√º hatasƒ±: {e}")
            time.sleep(30)

    logger.info("‚ÑπÔ∏è Live trading d√∂ng√ºs√º sonlandƒ±rƒ±ldƒ±")


def start_live_trading() -> bool:
    """üöÄ Live trading'i ba≈ülat."""
    global live_trading_active, live_trading_thread

    if live_trading_thread is not None and live_trading_thread.is_alive():
        logger.warning("‚ö†Ô∏è Live trading zaten aktif (thread alive)")
        return False
    if live_trading_active:
        logger.warning("‚ö†Ô∏è Live trading zaten aktif (flag)")
        return False

    if not live_bot.connect_to_binance():
        logger.error("‚ùå Binance API baƒülantƒ±sƒ± ba≈üarƒ±sƒ±z")
        return False

    logger.info("üöÄ Live Trading ba≈ülatƒ±lƒ±yor...")
    logger.info(f"üîë Environment: {ENVIRONMENT}")
    logger.info(f"üí∞ Ba≈ülangƒ±√ß bakiyesi: ${live_bot.account_balance:.2f}")
    logger.info(f"üìä Maksimum pozisyon: {MAX_OPEN_POSITIONS}")
    logger.info(f"‚è∞ Tarama aralƒ±ƒüƒ±: {SCAN_INTERVAL} saniye")
    logger.info(f"üõë Stop Loss: %{STOP_LOSS_PCT * 100}")
    logger.info(f"üéØ Take Profit: %{TAKE_PROFIT_PCT * 100}")
    logger.info(f"ü§ñ Otomatik SL/TP: Binance sunucu tarafƒ±nda aktif")
    logger.info(f"üî• AI SKOR Mƒ∞Nƒ∞MUM: 30%")

    live_trading_active = True

    live_trading_thread = threading.Thread(target=live_trading_loop, daemon=True)
    live_trading_thread.start()

    logger.info("‚úÖ Live Trading ba≈ülatƒ±ldƒ±")
    return True


def stop_live_trading() -> None:
    """üõë Live trading'i durdur."""
    global live_trading_active

    if not live_trading_active:
        logger.info("üí§ Live trading zaten durdurulmu≈ü")
        return

    logger.info("üõë Live Trading durduruluyor...")
    live_trading_active = False

    if open_positions:
        logger.info(f"üìö {len(open_positions)} a√ßƒ±k pozisyon toplu kapatƒ±lƒ±yor...")
        for symbol in list(open_positions.keys()):
            live_bot.close_position(symbol, "Trading Stopped")
            time.sleep(0.5)

    logger.info("‚úÖ Live Trading durduruldu")


def is_live_trading_active() -> bool:
    """üìä Live trading aktif mi?"""
    return live_trading_active


def get_live_trading_status() -> Dict:
    """üìä Live trading durum bilgilerini al."""
    auto_sltp_count = sum(1 for p in open_positions.values() if p.get("auto_sltp", False))
    
    return {
        "is_active": live_trading_active,
        "api_connected": live_bot.is_connected,
        "balance": live_bot.account_balance,
        "environment": ENVIRONMENT,
        "open_positions": len(open_positions),
        "max_positions": MAX_OPEN_POSITIONS,
        "auto_sltp_positions": auto_sltp_count,
        "auto_sltp_enabled": True,
    }


# üîß D√úZELTME: App.py'de eksik olan fonksiyonlarƒ± ekle
def get_live_bot_status_for_symbol(symbol: str) -> str:
    """üî• App.py callback'i i√ßin sembol durumu al"""
    try:
        if symbol in open_positions:
            pos = open_positions[symbol]
            if pos.get('auto_sltp', False):
                return "‚úÖü§ñ"  # A√ßƒ±k pozisyon + otomatik SL/TP
            else:
                return "‚úÖüì±"  # A√ßƒ±k pozisyon + manuel
        else:
            return "‚≠ê"  # Beklemede/deƒüerlendirilecek
    except:
        return "‚ùì"


def get_auto_sltp_count() -> int:
    """üî• App.py callback'i i√ßin otomatik SL/TP sayƒ±sƒ±"""
    try:
        return sum(1 for p in open_positions.values() if p.get("auto_sltp", False))
    except:
        return 0